precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('Total acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
cat(tab)
return (tab)
}
goodness_params(pred, test[,4])
goodness_params = function(pred, actual){
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('Total acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
return (tab)
}
goodness_params(pred, test[,4])
goodness_params = function(pred, actual){
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('\n\nTotal acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
return (tab)
}
goodness_params(pred, test[,4])
goodness_params = function(pred, actual){
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/(sum(cnf_mat[,i] + sum(cnf_mat[i,]))))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('\n\nTotal acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
return (tab)
}
goodness_params(pred, test[,4])
cnf
cnf_mat
goodness_params = function(pred, actual){
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))*(cnf_mat[i,i]/(sum(cnf_mat)/nrow(cnf_mat)))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('\n\nTotal acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
return (tab)
}
goodness_params(pred, test[,4])
0.5*(0.9643 + 0.9891)
240-54
186/240
goodness_params = function(pred, actual){
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))*(cnf_mat[i,i])
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('\n\nTotal acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
return (tab)
}
goodness_params(pred, test[,4])
goodness_params = function(pred, actual){
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat('\n\nTotal acc.:', total_accuracy, '\n\n')
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
return (tab)
}
goodness_params(pred, test[,4])
eval = goodness_params(pred, test[,4])
eval
eval = goodness_params(pred, test[,4])
?matrix
colnames(tab)[ncol(cnf_mat)+1] = 'Mean'
eval = goodness_params(pred, test[,4])
eval
eval = goodness_params(pred, test[,4])
eval
goodness_params(pred, test[,4])
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_metrics-util.R")
ncol(cnf_mat)+1
colnames(tab)
cnf_mat = table(factor(pred), factor(test[,ncol(test)]), dnn= c('Pred.', 'Ref.'))
precision = array(NA, dim = nrow(cnf_mat))
recall = array(NA, dim = nrow(cnf_mat))
F1 = array(NA, dim = nrow(cnf_mat))
accuracy = array(NA, dim = nrow(cnf_mat))
for (i in seq(along = 1:nrow(cnf_mat))){
precision[i] = cnf_mat[i,i] / sum (cnf_mat[i,])
}
for (i in seq(along = 1:nrow(cnf_mat))){
recall[i] = cnf_mat[i,i] / sum (cnf_mat[,i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
F1[i] = 2 * precision[i] * recall[i] / (precision[i] + recall[i])
}
for (i in seq(along = 1:nrow(cnf_mat))){
accuracy[i] = (cnf_mat[i,i]/sum(cnf_mat[,i]))
}
total_accuracy = sum(diag(cnf_mat)) / sum(cnf_mat)
cat(cnf_mat)
cat('\n\nTotal acc.:', total_accuracy, '\n\n')
means = matrix(c(round(mean(precision),4), round(mean(recall),4),
round(mean(F1),4),round(mean(accuracy),4)))
tab = matrix(c(round(precision,4), round(recall,4), round(F1,4),
round(accuracy,4)), ncol=ncol(cnf_mat), byrow=TRUE)
tab = c(tab, means)
colnames(tab) = paste('Class', 1:(ncol(cnf_mat)))
colnames(tab)[ncol(cnf_mat)+1] = 'Mean'
rownames(tab) <- c('Precision','Recall','F1', 'Accuracy')
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_metrics-util.R")
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
eval
source('./oen_metrics-util.R')
#confusion matrix
eval = goodness_params(pred, test[,4])
eval
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
print(eval)
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_decisiontree.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_decisiontree.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_decisiontree.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_decisiontree.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_decisiontree.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_fischer-score.R")
rm(list=ls())
set.seed(1337)
packages_used = c("rstudioapi",
"Rdimtools")
for(package in packages_used){
if(package %in% rownames(installed.packages()) == FALSE) {
install.packages(package)
}
}
setwd_current_path = function(){
library(rstudioapi)
current_path = getActiveDocumentContext()$path
setwd(dirname(current_path)) #get this current folder
#setwd('..') #go 1 up for scalability
print(getwd())
}
setwd_current_path()
library(Rdimtools)
load("./2gaussiandata.RData")
#x=generated_data
# TO-DO: make a function according to assignment
#assumes dataset with labels included
num_features = dim(x)[2]-1
num_samples = dim(x)[1]
features = x[,1:num_features]
labels = x[,num_features+1]
num_classes = length(unique(labels))
# can we use the mean / sd function?
#fischer score list
fischer_score = list()
for(y in seq(along = 1:num_features)){
#initialise intermediate calculations per feature
im_result = 0
sum_top = 0
sum_bottom = 0
#calculate the 'global mean' for this feature
mu = mean(x[,y])
for(z in seq(along = 1:num_classes)){
#get data for specific class (situated in last column features+1)
data_for_class = x[x[,num_features+1] == z,]
#calculate mean and std for this feature and class
mu_j = mean(data_for_class[,y], na.rm = TRUE)
std_j = sd(data_for_class[,y], na.rm = TRUE)
#get number of datapoints
p_j = nrow(data_for_class)/nrow(x)
#perform calculations according to formula
sum_top = sum_top + p_j*(mu_j - mu)**2
sum_bottom = sum_bottom + p_j*(std_j**2)
}
#perform final computation
im_result = sum_top/sum_bottom
#append to the list with Fischer scores
fischer_score[[y]] = im_result
}
cat(fischer_score)
# # third party implementation for validation
# fscore_thirdparty = do.fscore(features, labels)
# print("Most important features according to 3rd party: ")
# print(fscore_thirdparty$featidx)
# plot(fscore_thirdparty$Y, pch=19, col=factor(labels), main="Fisher Score")
rm(list=ls())
set.seed(1337)
packages_used = c("rstudioapi",
"Rdimtools")
for(package in packages_used){
if(package %in% rownames(installed.packages()) == FALSE) {
install.packages(package)
}
}
setwd_current_path = function(){
library(rstudioapi)
current_path = getActiveDocumentContext()$path
setwd(dirname(current_path)) #get this current folder
#setwd('..') #go 1 up for scalability
print(getwd())
}
setwd_current_path()
library(Rdimtools)
load("./3Dgauss.RData")
#assumes dataset with labels included
num_features = dim(x)[2]-1
num_samples = dim(x)[1]
features = x[,1:num_features]
labels = x[,num_features+1]
num_classes = length(unique(labels))
#fischer score list
fischer_score = list()
for(y in seq(along = 1:num_features)){
#initialise intermediate calculations per feature
im_result = 0
sum_top = 0
sum_bottom = 0
#calculate the 'global mean' for this feature
mu = mean(x[,y])
for(z in seq(along = 1:num_classes)){
#get data for specific class (situated in last column features+1)
data_for_class = x[x[,num_features+1] == z,]
#calculate mean and std for this feature and class
mu_j = mean(data_for_class[,y], na.rm = TRUE)
std_j = sd(data_for_class[,y], na.rm = TRUE)
#get number of datapoints
p_j = nrow(data_for_class)/nrow(x)
#perform calculations according to formula
sum_top = sum_top + p_j*(mu_j - mu)**2
sum_bottom = sum_bottom + p_j*(std_j**2)
}
#perform final computation
im_result = sum_top/sum_bottom
#append to the list with Fischer scores
fischer_score[[y]] = im_result
}
print(fischer_score)
# # third party implementation for validation
# fscore_thirdparty = do.fscore(features, labels)
# print("Most important features according to 3rd party: ")
# print(fscore_thirdparty$featidx)
# plot(fscore_thirdparty$Y, pch=19, col=factor(labels), main="Fisher Score")
rm(list=ls())
set.seed(1337)
packages_used = c("rstudioapi",
"Rdimtools")
for(package in packages_used){
if(package %in% rownames(installed.packages()) == FALSE) {
install.packages(package)
}
}
setwd_current_path = function(){
library(rstudioapi)
current_path = getActiveDocumentContext()$path
setwd(dirname(current_path)) #get this current folder
#setwd('..') #go 1 up for scalability
print(getwd())
}
setwd_current_path()
library(Rdimtools)
load("./3Dgauss.RData")
x=generated_data
#assumes dataset with labels included
num_features = dim(x)[2]-1
num_samples = dim(x)[1]
features = x[,1:num_features]
labels = x[,num_features+1]
num_classes = length(unique(labels))
#fischer score list
fischer_score = list()
for(y in seq(along = 1:num_features)){
#initialise intermediate calculations per feature
im_result = 0
sum_top = 0
sum_bottom = 0
#calculate the 'global mean' for this feature
mu = mean(x[,y])
for(z in seq(along = 1:num_classes)){
#get data for specific class (situated in last column features+1)
data_for_class = x[x[,num_features+1] == z,]
#calculate mean and std for this feature and class
mu_j = mean(data_for_class[,y], na.rm = TRUE)
std_j = sd(data_for_class[,y], na.rm = TRUE)
#get number of datapoints
p_j = nrow(data_for_class)/nrow(x)
#perform calculations according to formula
sum_top = sum_top + p_j*(mu_j - mu)**2
sum_bottom = sum_bottom + p_j*(std_j**2)
}
#perform final computation
im_result = sum_top/sum_bottom
#append to the list with Fischer scores
fischer_score[[y]] = im_result
}
print(fischer_score)
# # third party implementation for validation
# fscore_thirdparty = do.fscore(features, labels)
# print("Most important features according to 3rd party: ")
# print(fscore_thirdparty$featidx)
# plot(fscore_thirdparty$Y, pch=19, col=factor(labels), main="Fisher Score")
?dimtools
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_fischer-score.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_fischer-score.R")
x11()
plot(x[,1], x[,2], col = x[,3])
x11()
plot(x[,1], x[,2], col = x[,4])
x11()
plot(x[,1], x[,2], col = x[,4], xlab='x', ylab = 'y')
x11()
plot(x[,1], x[,2], col = x[,4], xlab='x', ylab = 'y')
title('Ground-truth of 3D dataset from X-Y perspective.')
x11()
plot(x[,1], x[,2], col = x[,4], xlab='x', ylab = 'y')
title('Ground-truth of 3D dataset from X-Y perspective')
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_decisiontree.R")
plot(test[,1], test[,2], col = misclassif_col, pch = 20)
title(paste('DT with ', nrow(test)-sum(pred == test[,ncol(test)]),
' out of ', nrow(test), ' misclassifications', sep=''))
x11()
plot(test[,1], test[,2], col = misclassif_col, pch = 20, xlab='x', ylab='y')
title(paste('DT with ', nrow(test)-sum(pred == test[,ncol(test)]),
' out of ', nrow(test), ' misclassifications', sep=''))
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_knn.R")
x11()
plot(test[,1], test[,2], col = misclassif_col, pch = 20, xlab='x', ylab='y')
title(paste(optim_neighs, '-NN with ', misclassif_list[optim_neighs],
' out of ', nrow(test), ' misclassifications', sep=''))
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_kerneltrick.R")
x11()
curve(y, from=-3, to=2, ylim=c(-1.5,1))
title('Polynomial kernel y = -1.37845*x_2**3 - 2.11278*x_2**2 + 0.0656642*x_2 + 0.2')
points(x_2, x_1, col=stm$clusters)
x11()
curve(y, from=-3, to=2, ylim=c(-1.5,1))
title('y = -1.37845*x_2**3 - 2.11278*x_2**2 + 0.0656642*x_2 + 0.2')
points(x_2, x_1, col=stm$clusters)
x11()
curve(y, from=-3, to=2, ylim=c(-1.5,1))
title('Polynomial kernel seperating two moons')
points(x_2, x_1, col=stm$clusters)
library(rgl)
plot3d(x_2, x_1, z, col = stm$clusters, xlab='x', ylab='y', zlab='z')
planes3d(0,0,1, alpha=0.5)
rgl.snapshot('kernel-trick-3d.png', fmt = "png")
x11()
curve(y, from=-3, to=2, ylim=c(-1.5,1))
title('Polynomial kernel separating two moons')
points(x_2, x_1, col=stm$clusters)
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_pca.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_pca.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_pca.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_kerneltrick.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_kerneltrick.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_pca.R")
source("G:/My Drive/1. EIT Digital master/Estland/Semester 1/Data mining/data-mining-iti8730-hw2/oen_pca.R")
barplot(expl_var, col = 'blue', xlab = 'PC', ylab = 'Variance')
x11()
barplot(expl_var, col = 'blue', xlab = 'PC', ylab = 'Variance')
title('Variance per Principal Component')
barplot(expl_var, col = 'blue', xlab = 'PC', ylab = 'Variance')
title('Variance per Principal Component')
